import * as fs from 'fs'
import minimist from 'minimist'
import glob from 'glob'
import * as path from 'path'
import fileType from 'file-type'
import camelcase from 'camelcase'
import * as chokidar from 'chokidar'
import * as packageJson from '../package.json'

function showToolVersion() {
  console.log(`Version: ${packageJson.version}`)
}

function globAsync(pattern: string, ignore?: string | string[]) {
  return new Promise<string[]>((resolve, reject) => {
    glob(pattern, { ignore }, (error, matches) => {
      if (error) {
        reject(error)
      } else {
        resolve(matches)
      }
    })
  })
}

function writeFileAsync(filename: string, data: string) {
  return new Promise<void>((resolve, reject) => {
    fs.writeFile(filename, data, (error) => {
      if (error) {
        reject(error)
      } else {
        resolve()
      }
    })
  })
}

function getVariableName(filePath: string) {
  return camelcase(path.normalize(filePath).replace(/\\|\//g, '-'))
}

// tslint:disable-next-line:cognitive-complexity
async function executeCommandLine() {
  const argv = minimist(process.argv.slice(2), { '--': true })

  const inputFiles = argv._
  const showVersion = argv.v || argv.version
  if (showVersion) {
    showToolVersion()
    return
  }

  if (!inputFiles || inputFiles.length === 0) {
    throw new Error('Error: no input files.')
  }

  globAsync(argv._.length === 1 ? argv._[0] : `{${argv._.join(',')}}`).then(uniqFiles => {
    const base = argv.base

    const watchMode: boolean = argv.w || argv.watch
    if (watchMode) {
      const variables: Variable[] = []
      let count = 0
      chokidar.watch(inputFiles).on('all', (type: string, file: string) => {
        console.log(`Detecting ${type}: ${file}`)
        if (type === 'add' || type === 'change') {
          const index = variables.findIndex(v => v.file === file)
          imageToBase64(file, base).then(variable => {
            if (index === -1) {
              variables.push(variable)
            } else {
              variables[index] = variable
            }
            count++
            if (count >= uniqFiles.length) {
              writeVariables(argv, variables)
            }
          })
        } else if (type === 'unlink') {
          const index = variables.findIndex(v => v.file === file)
          if (index !== -1) {
            variables.splice(index, 1)
            writeVariables(argv, variables)
          }
        }
      })
    } else if (uniqFiles.length > 0) {
      Promise.all(uniqFiles.map(file => imageToBase64(file, base))).then(variables => {
        writeVariables(argv, variables)
      })
    }
  })
}

function imageToBase64(file: string, base: string) {
  return new Promise<Variable>((resolve, reject) => {
    fs.readFile(file, (error, buffer) => {
      if (error) {
        reject(error)
      } else {
        const mime = fileType(buffer).mime
        const base64 = `data:${mime};base64,${buffer.toString('base64')}`
        resolve({ name: base ? path.relative(base, file) : file, file, base64 })
      }
    })
  })
}

// tslint:disable-next-line:cognitive-complexity
function writeVariables(argv: minimist.ParsedArgs, variables: Variable[]) {
  variables.sort((v1, v2) => v1.name.localeCompare(v2.name))
  if (argv.json) {
    if (typeof argv.json === 'string') {
      writeFileAsync(argv.json, JSON.stringify(variables, null, '  '))
    } else {
      console.log(JSON.stringify(variables, null, '  '))
    }
  }
  if (argv.scss) {
    const content = generatedHead + variables.map(v => `$${v.name.split('.').join('-')}: '${v.base64}';\n`).join('')
    if (typeof argv.scss === 'string') {
      writeFileAsync(argv.scss, content)
    } else {
      console.log(content)
    }
  }
  if (argv.less) {
    const content = generatedHead + variables.map(v => `@${v.name.split('.').join('-')}: '${v.base64}';\n`).join('')
    if (typeof argv.less === 'string') {
      writeFileAsync(argv.less, content)
    } else {
      console.log(content)
    }
  }
  const es6 = argv.es6
  if (es6) {
    const wantTypescript = typeof es6 === 'string' && es6.endsWith('.ts')
    let content = generatedHead
    if (wantTypescript) {
      content += '// tslint:disable\n'
    } else {
      content += '// eslint:disable\n'
    }
    content += variables.map(v => `export const ${getVariableName(v.name)} = \`${v.base64}\`\n`).join('')
    if (wantTypescript) {
      content += '// tslint:enable\n'
    } else {
      content += '// eslint:enable\n'
    }
    if (typeof es6 === 'string') {
      writeFileAsync(es6, content)
    } else {
      console.log(content)
    }
  }
}

type Variable = { name: string; file: string; base64: string; }

const generatedHead = `/**
 * This file is generated by 'image2base64-cli'
 * It is not mean to be edited by hand
 */
`

executeCommandLine().then(() => {
  console.log('image to base64 success.')
}, error => {
  if (error instanceof Error) {
    console.log(error.message)
  } else {
    console.log(error)
  }
  process.exit(1)
})
